---
layout: post
title:  Generating Ethereum address from scratch
---

In this blog post I would like to introduce readers into Elliptic Curve
Cryptography and use this knowledge to construct an Ethereum address.

An Elliptic Curve is a curve define by the equation

$$y^2 = x^3 + ax +b,$$

The curve has a number of nice properties, and one of them is that if take two
points on the curve and draw a line through them, the line will intersect the
curve at exactly one point. You can play around with this property using the
[Bokeh] application below:


<details><summary>CODE</summary><p>
{% highlight python %}
import numpy as np

from bokeh.layouts import column, row
from bokeh.models import CustomJS, Slider
from bokeh.plotting import ColumnDataSource, figure, show


def create_layout(a: int, b: int, start_xs=[1, 6], x_max=15, flip=False):
    roots = np.roots([1, 0, a, b])
    min_ = roots[np.isreal(roots)][0].real
    while min_**3 + min_ * a + b < 0:
        min_ += 0.0001

    step = 0.01
    x_vals = np.arange(min_, x_max, step)
    y_vals = np.sqrt(x_vals**3 + a * x_vals + b)

    start_xs = np.array(start_xs)
    start_ys = np.sqrt(start_xs**3 + a * start_xs + b)
    if flip:
        start_ys[0] = -start_ys[0]
    source = ColumnDataSource(data=dict(x=start_xs, y=start_ys))

    line_xs = [x_vals.min()] + list(start_xs) + [x_vals.max()]
    slope = (start_ys[1] - start_ys[0]) / (start_xs[1] - start_xs[0])
    y_line_min = slope * (x_vals.min() - start_xs[0]) + start_ys[0]
    y_line_max = slope * (x_vals.max() - start_xs[0]) + start_ys[0]
    line_ys = [y_line_min] + list(start_ys) + [y_line_max]

    source_line = ColumnDataSource(data=dict(x=line_xs, y=line_ys))

    p1_slider = Slider(start=x_vals.min(), end=x_vals.max(), value=start_xs[0],
                       step=step, title="Point1")
    p2_slider = Slider(start=x_vals.min(), end=x_vals.max(), value=start_xs[1],
                       step=step, title="Point2")

    plot = figure(plot_width=400, plot_height=400)
    plot.line(x_vals, y_vals, line_width=2)
    plot.line(x_vals, -y_vals, line_width=2)

    plot.circle('x', 'y', source=source, size=10, color="navy", alpha=0.5)
    plot.line('x', 'y', source=source_line, line_width=1, color="black")

    minus = "-" if flip else ""
    callback = CustomJS(args=dict(source_dots=source,
                                  source_line=source_line,
                                  p1=p1_slider, p2=p2_slider),
                        code=f"""
        const data = source_dots.data;
        const x1 = p1.value;
        const x2 = p2.value;
        const x = data['x'];
        const y = data['y'];
        x[0] = x1;
        x[1] = x2;
        const y1 = {minus}Math.sqrt(Math.pow(x1, 3) + {a} * x1 + {b});
        const y2 = Math.sqrt(Math.pow(x2, 3) + {a} * x2 + {b});
        y[0] = y1;
        y[1] = y2;
        source_line.data['x'][1] = x1;
        source_line.data['x'][2] = x2;
        source_line.data['y'][1] = y1;
        source_line.data['y'][2] = y2;
        const slope = (y2 - y1) / (x2 - x1);
        source_line.data['y'][0] = slope * (source_line.data['x'][0] - x1) + y1;
        source_line.data['y'][3] = slope * (source_line.data['x'][3] - x1) + y1;
        source_dots.change.emit();
        source_line.change.emit();
    """)

    p1_slider.js_on_change('value', callback)
    p2_slider.js_on_change('value', callback)

    layout = column(
        plot,
        column(p1_slider, p2_slider),
    )

    return layout


l1 = create_layout(2, 29, flip=True)
l2 = create_layout(2, 29, flip=False)

show(row(l1, l2))
{% endhighlight %}
</p></details>

{::nomarkdown}<div id="elliptic" class="bk-root"></div>{:/}

{::nomarkdown}
<script type="text/javascript">
var request = new XMLHttpRequest();
request.open("GET", "../../../../../assets/elliptic.bokeh.js", false);
request.send(null)
var item = JSON.parse(request.responseText);
Bokeh.embed.embed_item(item, "elliptic");
</script>
{:/}

[Bokeh]: https://bokeh.pydata.org/en/latest/
